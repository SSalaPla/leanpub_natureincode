# 8. Cooperation: Good Guys Can Finish First

In this chapter, we are going to explore a simple question: Why is there cooperation? The narrative of evolution - "struggle for life", "survival of the fittest", "the selfish gene", etc - seems to suggest, superficially, that cooperation is a mystery. Evolution, this line of reasoning goes, is about cutthroat competitiveness, and raw self-interest: eat or be eaten. In such a world, why would individuals be cooperative or altruistic? This type of behavior should be wiped out by natural selection. But then why are these behaviors widespread in nature?

It turns out that natural selection and cooperation can be perfectly compatible. This has been one of the most exciting findings in evolutionary biology in the past few decades. The evolution of cooperation is still a very active research area, and we will once again only be able to scratch the surface of this exciting field. However, my goal is to convince you that we should not be puzzled by - and indeed often expect - cooperative behavior among individuals under many circumstances. And as before, I don't want you to take my word for it: I want you to create a virtual world in code, where individuals are subject to ruthless natural selection. And we will find that in such a world, cooperation can readily evolve, given certain conditions.

First, we will introduce a formal model than can be used to study the evolution of cooperation. Then, we'll see that in a very simple implementation of that model, cooperation doesn't stand a chance, confirming our original intuition that cooperation and evolution are not necessarily natural bedfellows. Following that, we'll show that a few simple but realistic modifications to the model will give rise to cooperative behavior. 

In addition, this chapter introduces a brand new programming concept: *objects*. Objects are the heart and soul of JavaScript, but as I hope to have demonstrated throughout the book, you can do an awful lot in JavaScript without ever knowing about objects. Nevertheless, understanding what objects are, and how to use them, enables you to write both cleaner and more complex code. 

Let's get started!

## Game Theory

The most common framework to study cooperation is that of *game theory*. Game theory is the study of strategic decision making. It was originally developed to study economic behavior, but was later adapted by evolutionary biologists to study behavior in non-human species as well.

Game theory gets its name from games, which are played by players who can act in certain ways, given some information. The outcome of the game is a payoff. When applied to economic theory, the payoff is usually monetary. However, when applied to evolutionary biology, the payoff is evolutionary fitness.   

The game that we would like to play here is as follows. Since we are interested in cooperation, we are going to assume that an individual can either *cooperate*, or *defect* (i.e. not cooperate). These are the only two possible actions. Given these two actions, or strategies, there are four possible combinations of two players playing a game:

{width="wide"}
|  |Individual 2 Defecting |Individual 2 Cooperating|
|:----------:|:------------:|:------------:|
| Individual 1 Defecting  |Payoff Individual 1: ?|Payoff Individual 1: ?|
|                         |Payoff Individual 2: ?|Payoff Individual 2: ?|
|:----------:|:------------:|:------------:|
| Individual 1 Cooperating  |Payoff Individual 1: ?|Payoff Individual 1: ?|
|                           |Payoff Individual 2: ?|Payoff Individual 2: ?|

In order to define the game, we now have to come up with the fitness values for each individual in each of the four possible combinations. By doing so, we are generating a payoff matrix that defines a game.

If we broadly think of cooperation as paying a cost, *c*, to help another player receive a benefit, *b*, we can fill in the payoff matrix generically as follows:

{width="wide"}
|  |Individual 2 Defecting |Individual 2 Cooperating|
|:----------:|:------------:|:------------:|
| Individual 1 Defecting  |Payoff Individual 1: 0|Payoff Individual 1: b|
|                         |Payoff Individual 2: 0|Payoff Individual 2: -c|
|:----------:|:------------:|:------------:|
| Individual 1 Cooperating  |Payoff Individual 1: -c|Payoff Individual 1: b-c|
|                           |Payoff Individual 2: b|Payoff Individual 2: b-c|

If the benefit is larger than the cost (i.e. *b > c*), this payoff matrix represents the so-called "Prisoner's dilemma" game, which is a classic game in evolutionary game theory. The game was originally developed in a non-biological context, but its logic can easily be applied to many biological situations. The gist of the game - and the reason why it is called a dilemma - is as follows. In essence, it would be best for a pair of players to cooperate - they would get a positive payoff of *b-c*, which is larger than 0. On the other hand, if they both defected, they would not receive any payoff (0). However, if one of them defects, and the other cooperates, the defector receives the benefit *b*, without having to pay the cost *c*, while the cooperator has to pay the cost *c*, without receiving the benefit *b*.

The consequence of this payoff matrix is that *it is always in the selfish interest of individuals to defect*. Why is that? Imagine you are playing this game, and you are contemplating your move - should you cooperate, or defect? If you expect the other player to cooperate, it will be better for you to defect, because your payoff will be *b* instead of the smaller *b-c*. Equally, if you expect the other player to defect, it will also be better for you to defect, because your payoff will be 0, which is still better than the negative payoff of *-c*. In short, no matter what the other player plays, your best move, selfishly, is to defect. Sadly, the outcome of this is that all individuals will defect, leading to the worst possible outcome for all interactions. It would be much better for everyone if everyone cooperated (they would all receive a positive payoff of *b-c*), but because it is individually better to defect, everyone will end up defecting, receiving no payoff at all.

It's important to recall that in a biological situation, the payoff is measured in evolutionary fitness (and as always, we care about the relative fitness values, and not about the absolute numbers). If we assume that playing a strategy is genetically encoded, a higher payoff simply means that an allele causing the individual to play a certain strategy will on average leave more of its copies in the next generation - and we'll get evolution by natural selection, as discussed in chapter 6. Of course, behavior is generally a very complex mechanism, influenced by many genes as well as by the environment. Thus, while there is certainly no one gene or allele "for" a complex behavior, we will continue to use this language metaphorically. As long as there is inheritance of whatever it is that causes individuals to play certain strategies, the logic of natural selection applies.

Let's go ahead and implement this game in JavaScript. 

## A Game in Code
First, as always, we'll set up some key variables:

~~~~~~~~
var c = 1;
var b = 4;

var population = [];
var population_size = 100;
var number_of_time_steps = 1000;
var mutation_rate = 0.001;

var strategies = ["ALL_C","ALL_D"];
var data = [];
~~~~~~~~

The variables `c` and `b` define the costs and benefits for our model. The array `population` is where we will store all the individuals in the population, and `population_size` defines how many individuals we will keep track of in the population. We'll be running a simulation for `number_of_time_steps` time steps, and we'll mutate strategies at the rate given by `mutation_rate` (more about that below). There are two possible strategies for an individual to take: `ALL_C` (meaning the individual will always cooperate) or `ALL_D` (meaning the individual will always defect). We store these two strategies as strings in the array `strategies`. Finally, we will store the frequency of the strategies in the `data` array for easy plotting.

You can think about time steps as generations, if you want to. But you could also imagine that time steps are simply arbitrary time intervals in which everyone in a population plays a game. I'll stick with the term time steps, rather than generations, because it is a more generic term.

To run a simulation, we will define, and immediately call, the function `run_simulation()`. Here's what it'll look like:

~~~~~~~~
function run_simulation() {
    init_simulation();
    for (var i = 0; i < number_of_time_steps; i++) {
        run_time_step();
    }
}

run_simulation();
~~~~~~~~

The function `run_simulation()` first calls another function, `init_simulation()`, to set up the initial population and the data collection. Then, using a `for` loop, we'll call the function `run_time_step()` as many times as defined by the variable `number_of_time_steps`.

Let's go ahead and implement these two functions. The function `init_simulation()` looks as follows:

~~~~~~~~
function init_simulation() {
    for (var i = 0; i < population_size; i++) {
        population.push(new Individual("ALL_C",0));
    }
    for (i = 0; i < strategies.length; i++) {
        data.push([]);
    }
}
~~~~~~~~

As you can see, there are two `for` loops used here: first, to initialize the population, and second, to set up the data collection using the `data` array. The second `for` loop should be self-explanatory at this stage: it simply adds an empty array to `data` for each strategy. So once again, `data` will be a two-dimensional array, where the inner arrays will contain the frequencies for the corresponding strategy at each time step.

The first `for` loop needs as more extensive discussion. The loop itself is rather simple: it simply pushes elements into the `population` array. But what kind of elements? Well, our `population` array is supposed to keep track of all the individuals. In the previous examples in this book, we kept track of individuals simply as genotypes, or alleles, or as states, usually by using a number or a string (such as `"A1"`, `"A2"`, `"S"`, `"I"`, `"R"`, etc.). However, many times, the elements that we want to store are more complex than that. For example, for the current model, we would like to store both a strategy - such as cooperate or defect - and a numerical payoff value for each individual. We could go ahead and store these values in an array:

~~~~~~~~
population.push(["C",0]);
~~~~~~~~

But then, we would always have to remember that the strategy is stored as the first element of the array, and the payoff as the second element. And what if we added more values to an individual? We would have to extend the array. And let's hope we would never come up with the idea to change the order in which we store these individual properties in the array - we would have to change the code everywhere we access the properties! This sounds like a recipe for disaster.

Enter *objects*. Objects are a very powerful concept, and yet they are very easy to understand. In JavaScript, an object is simply a container of properties. Properties are named values, i.e. they have a name, and a value. You can define an object using the shorthand notation `{}`. 

Recall how we introduced arrays in chapter 3 - we saw that you can initialize an empty array using the shorthand notation `[]`, like so:

~~~~~~~~
var array = [];
~~~~~~~~

or you can initialize the array with some values right away:

~~~~~~~~
var array = [1,4,7];
~~~~~~~~

Similarly, you can initialize an empty object like this:

~~~~~~~~
var object = {};
~~~~~~~~

and alternatively, you can initialize the object with a few properties right away:

~~~~~~~~
var object = {"first_name":"marcel", "last_name":"salathe"};
~~~~~~~~

As you can see, this object contains two properties. One has the name `"first_name"`, and the value `"marcel"`; the other has the name `"last_name"`, and the value `"salathe"`. Property names can be strings, but you can omit the quotes if the names are legal JavaScript variable names (which I highly recommend they are). In other words, you could initialize the same object as follows:

~~~~~~~~
var object = {first_name:"marcel", last_name:"salathe"};
~~~~~~~~

So that's how you set the property values - but how do you retrieve them when you need them later on? JavaScript provides two notations to access property values: the *dot notation*, and the shorthand notation `[]`. For example, in order to retrieve the value of the property `first_name`, you could use either 

~~~~~~~~
object.first_name
~~~~~~~~

or 

~~~~~~~~
object["first_name"]
~~~~~~~~

independent of how you defined it. Throughout the rest of this book, I will use the dot notation, which I prefer because it is shorter and cleaner. 

Now, for the purpose of our model, we would like to store individuals as objects with two properties. Those properties are (i) the strategy of the individual, and (ii) the payoff. The strategy can be of value `"ALL_C"` or `"ALL_D"` (for cooperator and defector, respectively), and the payoff is a numerical value initially set to 0. Thus, we could create individuals like so:

~~~~~~~~
var individual_0 = {strategy:"ALL_C", payoff:0};
var individual_1 = {strategy:"ALL_D", payoff:0};
var individual_2 = {strategy:"ALL_C", payoff:0};
var individual_3 = {strategy:"ALL_D", payoff:0};
...
~~~~~~~~

But this is a bit cumbersome, especially if we repeatedly want to generate new objects of the same kind. It turns out that JavaScript provides a very handy object generator. It is called *constructor function*, which is simply a function that by convention starts with a capital letter, and is invoked with the `new` keyword. Let's take a look at this step by step.

Like any function, a constructor function can take any number of arguments. For example, a constructor function for an individual could look like this:

~~~~~~~~
function Individual(strategy, payoff) {

}
~~~~~~~~

This function doesn't do anything - yet. What we would like to do, though, is for the function to create a new object, assign values to the properties, and return the object. It turns out that when we invoke the function with the `new` keyword, like so:

~~~~~~~~
var example_individual = new Individual("C",0);
~~~~~~~~

then the constructor implicitly creates a new empty object, assigns it to a local variable called `this`, and returns `this` at the end of the function. Thus, if we want to assign the parameter values to the corresponding properties, our constructor function should look like this:

~~~~~~~~
function Individual(strategy, payoff) {
    this.strategy = strategy;
    this.payoff = payoff;
}
~~~~~~~~

Note that we neither have to write `var this = {};` at the beginning, nor `return this;` at the end - both of these things happen automatically if the function is invoked with the keyword `new`. Which is of course exactly what we are doing in the first `for` loop in the function `init_simulation()`:

~~~~~~~~
for (var i = 0; i < population_size; i++) {
    population.push(new Individual("ALL_C",0));
}
~~~~~~~~

Thus, in every iteration of this loop, we create a new object using the Individual constructor function, and each of these created objects has two properties, `strategy` and `payoff`, which are set to `"ALL_C"` and `0`, respectively.

After this brief detour to introduce JavaScript objects, let's return to our function `run_simulation()`, which repeatedly calls the function `run_time_step()` which is currently undefined - let's fix that and define `run_time_step()` like this:

~~~~~~~~
function run_time_step() {
    games();
    selection();
    mutation();
}
~~~~~~~~
  
As you can see, this function does not do much by itself, other than calling three functions in sequence: `games()`, which is the function where all individuals play their games; `selection()`, which is the function that replaces the strategies of individuals that have low payoffs with strategies of individuals that have high payoffs; and `mutation()`, which introduces the occasional random strategy change. Let's take a look at each of these functions in detail.

The `games()` function is where we make all individuals play a game against another, randomly chosen individual. We can implement this as follows:

~~~~~~~~
function games() {
    for (var i = 0; i < population_size; i++) {
        var current_individual = population[i];
        var other_individual = get_other_individual(current_individual);
        play_game(current_individual, other_individual);
    }
}
~~~~~~~~

This function loops through all individuals, picks another, random individual, and then makes the two individuals play the game. Let's first implement the function `get_other_individual()`:

~~~~~~~~
function get_other_individual(individual) {
    do {
        var random_index = get_random_int(0,population_size-1);
        var other_individual = population[random_index];
    }
    while (other_individual == individual);
    return other_individual;
}

// get_random_int helper function that we developed in chapter 5
function get_random_int(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
~~~~~~~~

As you can see, the reason why we pass an `individual` to this function is so that we can make sure that the other, random individual truly is another individual: otherwise, we would occasionally play a game against ourselves. Playing the game against yourself would give you an unfair advantage because you would potentially receive twice the payoff. We can easily ensure that the other individual is not equal to the individual we passed in as an argument by comparing whether they are equal, as we do in the line

~~~~~~~~
while (other_individual == individual);
~~~~~~~~

What the function does is to pick a random individual for as long as it is necessary (i.e. for as long as the two individuals are in fact the same individual).

There is a JavaScript gotcha here that I want you to be aware of. Until now, whenever we compared values and tested for equality, we were comparing so-called *primitive* types such as numbers (e.g. `1`, `2`), booleans (`true`, `false`), and strings (e.g. `"A1"`, `"A2"`). These values are called primitive types because they are not objects. When you are comparing primitive types, you are comparing their values. However, when you are comparing objects, you are not actually comparing their values - you are simply comparing their *references*. What does this mean?

A reference is essentially an address in memory where your object lives. When you compare two objects with the equality operator `==`, you are not comparing the values of their properties; you are simply comparing the reference. 

Consider the following code:

~~~~~~~~
var obj1 = {foo:1, bar:2};
var obj2 = {foo:1, bar:2};
console.log(obj1 == obj2);
~~~~~~~~

This code would write `false` into the console. The reason is that even though the two objects have the exact same properties (identical names and values), they are different in that they live at two different addresses in memory. They literally are two different objects.

You may ask yourself, can objects ever live at the same address? Yes, they can - consider the following code which is only slightly changed from the code above:

~~~~~~~~
var obj1 = {foo:1, bar:2};
var obj2 = obj1;
console.log(obj1 == obj2);
~~~~~~~~

This code would write `true` into the console. The main reason lies in the second line, when `obj2` is assigned the value of `obj1`. **Oops, I misspoke!** In fact -  and that is the main message here - it is the *reference*, not the *value* of `obj1`, that is assigned to `obj2`.

The official wording for this in computer science is that in JavaScript, objects are *passed by reference*, rather than by value. Primitive types, on the other hand, are passed by value.

This has a number of very important implications. Consider this code:

~~~~~~~~
var a = 5;
var b = a;
console.log(a,b);
a = 3;
console.log(a,b);
~~~~~~~~

Can you guess what this code will do? At first, you would see

~~~~~~~~
5 5 
~~~~~~~~

in the console, because both variables have the value `5`. When `a` is overwritten to be of value `3`, `b` is not changed, and the output is 

~~~~~~~~
3 5
~~~~~~~~

as we would intuitively expect.

We have never talked about this issue before because when you work with primitive types, things seem intuitively logical, as seen in the code example above. However, this changes with objects. Let's look at the following code with objects, which is the same code in spirit as the one above:

~~~~~~~~
var a = {foo:1, bar:2};
var b = a;
console.log(a,b);
a.foo = 3;
console.log(a,b);
~~~~~~~~

At first, you will see the output 

~~~~~~~~
Object {foo: 1, bar: 2} Object {foo: 1, bar: 2} 
~~~~~~~~

(Your output might look slightly different depending on your browser.) But then, you might be surprised to see the second output, which reads:

~~~~~~~~
Object {foo: 3, bar: 2} Object {foo: 3, bar: 2}
~~~~~~~~

You may have thought that you had only changed the value of the `foo` property in object `a`. *But you don't really have two distinct objects*: `b` is simply assigned a reference to `a`, and because you changed `a.foo`, you will see the change reflected in both `a` and `b`.

If that seems a bit confusing a first, don't worry - you're in good company. We'll revisit this issue multiple times until it sinks in.

After this short detour about objects, let's bring our attention back to the cooperation model code. We were just talking about this function:

~~~~~~~~
function get_other_individual(individual) {
    do {
        var random_index = get_random_int(0,population_size-1);
        var other_individual = population[random_index];
    }
    while (other_individual == individual);
    return other_individual;
}
~~~~~~~~

which returns an `other_individual` that is different from the `individual`. And we now understand that it is different in the sense that it is indeed a different object, even though it might have the exact same properties.

Now that we have a second, distinct individual, we pass both individuals as arguments to the `games()` function, where they play a game together. Keep in mind that a game is defined by the payoff matrix that we developed above, which looks as follows:

{width="wide"}
|  |Individual 2 Defecting |Individual 2 Cooperating|
|:----------:|:------------:|:------------:|
| Individual 1 Defecting  |Payoff Individual 1: 0|Payoff Individual 1: b|
|                         |Payoff Individual 2: 0|Payoff Individual 2: -c|
|:----------:|:------------:|:------------:|
| Individual 1 Cooperating  |Payoff Individual 1: -c|Payoff Individual 1: b-c|
|                           |Payoff Individual 2: b|Payoff Individual 2: b-c|

How can we incorporate this in code? Here's how:

~~~~~~~~
function play_game(individual1, individual2) {
    var move_individual1 = individual1.compute_move();
    var move_individual2 = individual2.compute_move();
    if (move_individual1 == "C") {
        if (move_individual2 == "C") {
            individual1.add_to_payoff(b - c);
            individual2.add_to_payoff(b - c);
        }
        else {
            individual1.add_to_payoff(-c);
            individual2.add_to_payoff(b);
        }
    }
    else {
        if (move_individual2 == "C") {
            individual1.add_to_payoff(b);
            individual2.add_to_payoff(-c);
        }
    }
}
~~~~~~~~

This code is in principle quite easy to understand. You first compute which of the two possible moves - cooperate (`"C"`) or defect (`"D"`) each individual is going to make. Then, depending on the combination of the two moves, you assign payoff values as outlined in the payoff matrix above.

What is perhaps a little perplexing is that the functions that we are calling to do these things - `compute_move()` for computing an individual's move, `add_to_payoff()` for adding a value to the payoff of an individual - are not just stand-alone functions, as we have used them throughout the book. Instead, they are functions called directly on the objects, using the dot notation like so:

~~~~~~~~
individual1.compute_move();
~~~~~~~~

When a function is used on an object, like we are doing here, it is usually called a *method*. While we have not defined or own methods until now, we have used methods before - remember our good old friend `Math.random()`? Yep, `random()` is a method, defined in the `Math` object, and called using the dot notation, exactly as we do in `individual1.compute_move()`!

Thus, all that is left to do is to define these two methods. Since they are part of the `Individual` object, they will need to be defined in the corresponding constructor function. After adding the two functions, our `Individual` constructor function will read like this:

~~~~~~~~
function Individual(strategy, payoff) {
    this.strategy = strategy;
    this.payoff = payoff;
    this.compute_move = function() {
        return this.strategy == "ALL_C" ? "C" : "D";
    };
    this.add_to_payoff = function(game_payoff) {
        this.payoff += game_payoff;
    };
} 
~~~~~~~~

Let's take a detailed look at this, because this looks nothing like anything we have seen before. Let's first take a look at the following three lines:

~~~~~~~~
this.compute_move = function() {
    return this.strategy == "ALL_C" ? "C" : "D";
};
~~~~~~~~

This defines the `compute_move()` method. It returns `"C"` if the individual's strategy is `"ALL_C"`, and `"D"` otherwise, using the ternary operator. Defining a method in an object has the following notation:

~~~~~~~~
this.method_name = function() {};
~~~~~~~~

where you are then free to make the method do whatever it needs to do inside the curly brackets `{}`.

This looks a little strange at first, because we have so far defined regular function like so:

~~~~~~~~
function function_name() {
}
~~~~~~~~

Indeed, we could have written this instead as 

~~~~~~~~
var function_name = function() {};
~~~~~~~~

which would have been equivalent. In JavaScript, functions are are in fact special objects, and just like you can assign an object to a variable, you can also assign a function to a variable. However, for stand-alone functions in my code, I generally prefer the slightly shorter notation 

~~~~~~~~
function function_name() {
}
~~~~~~~~

However, when you define methods as parts of your objects, you can't use this short notation anymore, an instead need to use the assignment notation, like we have done above:

~~~~~~~~
this.compute_move = function() {
    return this.strategy == "ALL_C" ? "C" : "D";
};
~~~~~~~~

After defining a method, you can then use it on any object as part of which it was defined - in our case, we can use it on any `Individual` object, as we do in the `games()` function:

~~~~~~~~
individual1.compute_move();
~~~~~~~~

The second method we have defined is the following:

~~~~~~~~
this.add_to_payoff = function(game_payoff) {
    this.payoff += game_payoff;
};
~~~~~~~~

This should now make more sense. The method `add_to_payoff()` has one parameter, `game_payoff` (which is the payoff from a single game), which it adds to the `payoff` property of the object like so:

~~~~~~~~
this.payoff += game_payoff;
~~~~~~~~

As this line of code demonstrates, you still have access to the object in the method body, through the variable `this`. Because of that, methods allow you to read and write the values of all the properties of the object, which is to a large extent the purpose of object methods.

Now that we are finished with the `games()` function, let's move on and define the `selection()` function.

As we mentioned at the beginning of the chapter, in evolutionary game theory, the payoff is not monetary, but rather evolutionary fitness: the higher your payoff, the higher your fitness. In chapter 6, where we discussed natural selection, we implemented selection by increasing the frequency of a genotype in a population in proportion to its fitness. In the model here, however, we are using a slightly modified version that is better suited for individual-based models. On average, it will roughly produce the same outcome: individuals with higher fitness will increase in frequency, and individuals with lower fitness will decrease in frequency.

Concretely, we are going to implement a very simple idea: for each individual, we'll pick another individual randomly, and then compare the fitnesses (i.e. payoffs) of the two individuals. If the randomly picked individual has a higher fitness than the focal individual, the focal individual will copy the random individual's strategy, otherwise it will keep its current strategy.

Here is how we will implement this idea:

~~~~~~~~
function selection() {
    var temp_population = [];
    for (var i = 0; i < population_size; i++) {
        var current_individual = population[i];
        var other_individual = get_other_individual(current_individual);
        if (other_individual.payoff > current_individual.payoff) {
            temp_population[i] = other_individual;
        }
        else {
            temp_population[i] = current_individual;
        }
    }
    for (i = 0; i < population_size; i++) {
        current_individual = population[i];
        current_individual.strategy = temp_population[i].strategy;
        current_individual.payoff = 0;
    }
}
~~~~~~~~

As we have done a few times before, we'll make use of a temporary data structure - an array called `temp_population` in this case - to store the new values in order to ensure that all individuals get updated simultaneously (if you don't know why we're doing this, be sure to re-read chapter 5). 

The function is divided into two `for` loops. The first `for` loop iterates over all individuals in the population, and for each individual, we pick a another, random individual, and compare the two fitness values. Then, depending on the values, we copy the properties of one of the two individuals into the temporary array.

Let's take a look at this line:

~~~~~~~~
temp_population[i] = other_individual;
~~~~~~~~

As we have discussed just a few pages earlier, because we're dealing with objects, temp_population[i] will now simply contain a reference to the other_individual object, rather than a copy of the object. This is important - let's now look at the second `for` loop and see why. It reads:

~~~~~~~~
for (i = 0; i < population_size; i++) {
    current_individual = population[i];
    current_individual.strategy = temp_population[i].strategy;
    current_individual.payoff = 0;
}
~~~~~~~~

As you can see, we are copying the `strategy` property from the individual that's referenced by `temp_population[i]`, and we are resetting the `payoff` property of the individual to 0 (because at each new time step, individuals should start with a payoff of 0 before they participate in a new round of games).

Let's take a look at what would be the *wrong* way to do this. The wrong way would be to implement this loop as follows:

~~~~~~~~
// the WRONG way!!
for (i = 0; i < population_size; i++) {
    current_individual = temp_population[i];
    current_individual.payoff = 0;
}
~~~~~~~~

This is very tempting: simply copy over the individual from the `temp_population` array, and then set its payoff back to `0` - simple, right? 

The problem with this that the line

~~~~~~~~
current_individual = temp_population[i];
~~~~~~~~

doesn't copy an object - it simply assigns a reference. Thus, `current_individual`, rather than being the same object as before (but simply with a new property values) would now actually reference another object somewhere in memory, which will lead to very confusing and completely wrong dynamics.

Because this concept can be a little trick to wrap your head around at first, I'm going to divert from our cooperation code, and will briefly introduce a completely independent code example that explains the concept in a simpler context. We'll get back to our cooperation code right after this. 

## Revisiting Object Assignments

Take a look at the following code:

~~~~~~~~
function Individual(fitness, trait) {
    this.fitness = fitness;
    this.trait = trait;
}

var individual1 = new Individual(1, "A");
var individual2 = new Individual(1.1, "B");
var individual3 = new Individual(1.2, "C");

console.log("initial population:")
console.log(individual1);
console.log(individual2);
console.log(individual3);

// selection:
individual1 = individual3;
individual2 = individual3; 
// individuals 2 and 3 should now have trait "C"
			
console.log("population after selection:")
console.log(individual1); // shows trait "C"
console.log(individual2); // shows trait "C"
console.log(individual3); // shows trait "C"      	

// mutate only individual3			
individual3.trait = "D";
			
console.log("population after mutation:")
console.log(individual1); // oops - shows trait "D"!!
console.log(individual2); // oops - shows trait "D"!!
console.log(individual3); // shows trait "D"
~~~~~~~~

Let's walk through this code slowly. This is a very simplified version of a selection-mutation process, with a population of three individuals.

On the first few lines, we defined the object `Individual`, which has two properties: a `fitness` property, and a `trait` property. We then create three individuals with different values. The object `individual1` has a `fitness` value of `1`, and `trait` value of `"A"`. The object `individual2` has a `fitness` value of `1.1`, and `trait` value of `"B"`. The object `individual3` has a `fitness` value of `1.2`, and `trait` value of `"C"`. We then print those objects to the console so that we can check that everything is working fine.

Then, selection takes place, and we want both `individual1` and `individual2` to copy over the values of the fittest individual in the population, `individual3`:

~~~~~~~~
// selection:
individual1 = individual3;
individual2 = individual3;
~~~~~~~~

Spoiler alert: this is where things go wrong- but more about that in a second. In any case, if we now print the three `Individual` objects into the console, we see that they all have trait `"C"`, which is what we wanted.

In the final step of this example, we assume that `individual3` mutates, and changes its trait to `"D"`. Note that we only change `individual3` - we don't touch `individual1` and `individual2`. However, if we now print the objects one more time into the console, we see that they all have trait `"D"`! How did that happen? We did not touch the traits of `individual1` or `individual2` anywhere in the code!

As I mentioned above, the problem is in these lines:

~~~~~~~~
// selection:
individual1 = individual3;
individual2 = individual3;
~~~~~~~~

We might think we're copying the object `individual3`, with all its properties, into `individual1` and `individual2` - *but we're not*. Instead, we are copying the *reference* to `individual3`. After these two lines, both `individual1` and `individual2` are simply references to `individual3`. In a way, with these two lines, we have "lost" two objects - all we have left is object `individual3`, and two other variables (`individual1` and `individual2`) referencing `individual3`.

When we print the three objects into the console after the selection step, it's very easy to think everything went fine, because all three objects now have trait `"C"` - but this is an illusion! It's simply that they are all referencing the same object, which happens to have trait `"C"`. And this illusion is exposed when we assign a new value to the trait of `individual3`: suddenly all individuals have trait `"D"`, because they are all pointing to `individual3`.

Here is a visual representation of what's going on (I've color-coded the objects to reflect distinct trait values): 

{width=90%}
![](images/ch_8_obj_example.png)

I hope this clarifies the issue, and ensures that you'll be on the lookout whenever you assign objects to variables. But having identified the problem, what is the correct why of doing it? In this particular example, the correct way would be to do the following - rather than copying the objects (or the references, as you now know), copy the properties instead. In other words, instead of these two lines:

~~~~~~~~
individual1 = individual3;
individual2 = individual3;
~~~~~~~~

you would have these four lines (assuming you want to copy both properties):

~~~~~~~~
individual1.trait = individual3.trait;
individual1.fitness = individual3.fitness;
individual2.trait = individual3.trait;
individual2.fitness = individual3.fitness;
~~~~~~~~

If you replace the two wrong lines with three correct lines and run this code again in your browser, you will see that after the mutation step, only `individual3` will have the trait value `"D"` - both `individual1` and `individual2` will still have trait value `"C"`, as they should have.

If you have very complex objects with many properties, it might be worthwhile writing a custom method for your object that copies the object's values. In our example, we could have decided to do this for our `Individual` object, which would look like this:

~~~~~~~~
function Individual(fitness, trait) {
    this.fitness = fitness;
    this.trait = trait;
    this.copy = function() {
        return new Individual(this.fitness, this.trait);
    }
}
~~~~~~~~

With that in place, we can replace the lines

~~~~~~~~
individual1.trait = individual3.trait;
individual1.fitness = individual3.fitness;
individual2.trait = individual3.trait;
individual2.fitness = individual3.fitness;
~~~~~~~~

with 

~~~~~~~~
individual1 = individual3.copy();
individual2 = individual3.copy();
~~~~~~~~

The benefit of this method is that you can adapt it easily when your object definition changes. 

One final caveat before we return to the main thread of cooperation: if your objects get very complex, some of the object's properties may themselves be objects! Indeed, their properties could also be objects, etc. - as many hierarchical levels as you want. If that's the case, be extra careful about what we just talked about; all objects behave the same, whether they are standalone, or deeply nested within other objects.

## When Defection Outcompetes Cooperation

Let's now return to our cooperation code. We have just finished implementing our `selection()` method. The final major method we need to implement is `mutation()`, which we will do as follows:

~~~~~~~~
function mutation() {
    for (var i = 0; i < population_size; i++) {
        if (Math.random() < mutation_rate) {
            var current_individual = population[i];
            current_individual.mutate();
        }
    }
}
~~~~~~~~

This function simply goes through all individuals in the population, and calls the `mutate()` method - which we'll need to define - on some of the individuals.

The `mutate()` method can be implemented as follows in the `Individual` constructor function:

~~~~~~~~
this.mutate = function() {
    if (this.strategy == "ALL_C") {
        this.strategy = "ALL_D";
    }
    else {
        this.strategy = "ALL_C";
    } 
};
~~~~~~~~

Thus, your complete `Individual` constructor function will look like this:

~~~~~~~~
function Individual(strategy, payoff) {
    this.strategy = strategy;
    this.payoff = payoff;
    this.compute_move = function() {
        return this.strategy == "ALL_C" ? "C" : "D";
    };
    this.add_to_payoff = function(game_payoff) {
        this.payoff += game_payoff;
    };
    this.mutate = function() {
        if (this.strategy == "ALL_C") {
            this.strategy = "ALL_D";
        }
        else {
            this.strategy = "ALL_C";
        }
    };
}
~~~~~~~~

And that's it - almost! The simulation would be working right now, but there is no way for us to see what's going on. First, let's go ahead and add some code so that we can print the results of the simulation into the console.

Of course, we'd like to see the frequencies of the strategies at each time step. So let's go ahead and modify our `run_time_step()` function which currently reads:

~~~~~~~~
function run_time_step() {
    games();
    selection();
    mutation();
}
~~~~~~~~

to

~~~~~~~~
function run_time_step() {
    games();
    selection();
    mutation();
    for (i = 0; i < strategies.length; i++) {
        data[i].push(get_number_with_strategy(strategies[i]) / population_size);
    }
}
~~~~~~~~
			
For each strategy, we need to know how many of the individuals have that specific strategy. We'll then divide that number by the population size, which gives us the frequency of the strategy in the population. The number will then be pushed in the corresponding array within `data`, for later usage. In order to get the number of individuals in the population with a given strategy, we'll define a helper function `get_number_with_strategy()`:

~~~~~~~~
function get_number_with_strategy(strategy) {
    var count = 0;
    for (var i = 0; i < population_size; i++) {
        if (population[i].strategy == strategy) {
            count++;
        }
    }
    return count;
}
~~~~~~~~

This function simply iterates over all individuals and increases a counter variable (called `count`) whenever the strategy of an individual is equal to a given strategy that was passed to the function as an argument.

Excellent! Now all that is left to do is print the results from the `data` array into the console. Do that, add the following code after your call to `run_simulation()`:
			
~~~~~~~~
for (var i = 0; i < number_of_time_steps; i++) {
    console.log(i,"ALL_C",data[0][i],"ALL_D",data[1][i]);
}
~~~~~~~~

Let's go ahead and run the entire code now! If you run it by loading the document in the browser, and look at the JavaScript console, you'll see something like this:

{width=35%}
![](images/ch_8_log_regular_pd_early.png)

What this shows is that the population starts with 100% `ALL_C` individuals, i.e. the population is composed entirely of cooperators; then, after a few generation, the first `ALL_D` (defector) mutants show up. From that point on, you can follow the fate of the two strategies by looking at the numbers.

If everything went ok with your code, you shouldn't have to scroll too far down in your JavaScript console to see something like this:

{width=35%}
![](images/ch_8_log_regular_pd_later.png)

(your specific numbers will vary of course - remember that this is a stochastic simulation). What you can see here is that the cooperators are completely driven to extinction by the defectors in just a few generations. Go ahead and reload the page - this happens every single simulation run, without an exception.

And of course, we shouldn't be surprised - indeed, we have just implemented a stochastic simulation of the prisoner's dilemma, and as we've seen in the beginning of the chapter, the outcome of the prisoner's dilemma is that defectors will always win, because it is always better for an individual (in terms of its payoff) to defect, rather than to cooperate. That is, after all, why it is called a dilemma: even though the total population payoff would be much higher if everyone cooperated, individuals will be better of if they defect. Thus, if everyone acts in their own self-interest, cooperation will collapse and be outcompeted by defection.

But we've shown repeatedly throughout this book that we can do better than print numbers into the the JavaScript console! In fact, the `draw_line_chart()` function that we've used so many times comes in quite hand here. If you simply add this line after your `run_simulation()` call:

~~~~~~~~
draw_line_chart(data,"time step", "frequency",[]);
~~~~~~~~

You will see the following dynamic in your browser:

{width=90%}
![](images/ch_8_dynamics_regular_pd.png)

The blue line is the frequency of cooperators (recall that we start each simulation with all cooperators), and the orange line is the frequency of defectors. Go ahead and reload the page - the dynamics, with slight stochastic variations, will always be identical: the cooperators are outcompeted by the defectors, generally within the first 100 time steps. The small bumps you can see in both lines are mutants showing up in the population, but none of them seem to be able to revert the dynamics. Again, this is as we expect it to be: in the regular prisoner's dilemma, it is always better for individuals to defect.

But hang on a second, I hear you say - didn't we start this chapter with the idea the cooperation would readily evolve? Glad you asked! Indeed, that's the promise with which I started the chapter. What we are going to do next is to introduce a small but realistic modification that will change the dynamics quite strongly. But first, I needed to convince you that pure cooperation, all by itself, does not stand a chance against pure defectors. And along the way, we developed an individual-based JavaScript simulation of a game-theoretical model (which is quite cool if you ask me - but of course I'm biased). This simulation will now form the basis of our exploration about the factors than can prevent the defectors from always winning.

I> This second part of the chapter is currently being written - as soon as its ready, I'll update the book. And as always, you can just get the updated version for free on the Leanpub website (you'll get notified by email when the update is ready).